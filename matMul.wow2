#include "convolution.hpp"
#include <pthread.h>

vector<vector<float> > resultG(3,vector<float>(3));


struct data{
  int row;
  int column;
  vector<vector<float> > Matrix;
  vector<float> kernel;
  vector<vector<float> > result;
  int m;
};


//bigmatrix is of dimension (((n-m)/stride)+1)*(((n-m)/stride)+1) x (m*m) := temp
// unrolled kernel of size m*mx1 := ker

void* matMulFun(void* arg){
  struct data *curr;
  curr = (struct data*) arg;
  int unr_ker_size = (curr->m)*(curr->m);
  vector<vector<float> > bigmat = curr->Matrix;
  vector<float> unr_ker = curr->kernel;
  float sum; 

  for (int j =0; j<unr_ker_size;j++){
    sum += bigmat[curr->row][j] * unr_ker[j];
  }
  (curr->result)[curr->row][curr->column] = sum;
  resultG[curr->row][curr->column] = sum;
}



vector<vector<float> > convm(vector<vector<float> > array, vector<vector<float> > kernel, int x, int stride){

//calling the padding  function   
    vector<vector<float> > arr = Padding(array, x);

    int n=arr.size();
    int m=kernel.size();
    int t=(((n-m)/stride) +1)*(((n-m)/stride) +1);

    int k=0;
    //float temp[t][m*m]; //the big matrix
    //float ker[m*m];   //unrolled kernel
    vector<vector<float> > temp(t,vector<float>(m*m));
    vector<float> ker(m*m);
//making an temp kernel so that we can use it for multiplication
    for(int i=0; i<m; i++){
      for(int j=0; j<m; j++){
        ker[k]=kernel[i][j];
        k+=1;
      }
    }
    k=0;

//Making the matrix from the input matrix and kernel 
    for(int i=0; i<n; i+=stride){
        for(int j=0; j<n; j+=stride){
            int l=0;
            if(i+m<=n && j+m<=n){
            for(int ii=0; ii<m; ii++){
              for(int jj=0; jj<m; jj++){
                temp[k][l]=arr[i+ii][j+jj];
                l+=1;
              }
             }
             k+=1;
            }else{
              break;
            }
        }
    }
cout <<"Wow!";
//Performing matrix multiplication and storing the result in the vector of size n-m+1 * n-m+1
//bigmatrix is of dimension (((n-m)/stride)+1)*(((n-m)/stride)+1) x (m*m) := temp
// unrolled kernel of size m*mx1 := ker
#define NUM_THREADS t
for (int i =0; i< t; i++){
// j will be 1; the number of columns of the resultant matrix
  struct data *curr = (struct data*)malloc(sizeof(struct data));
  curr -> Matrix = temp;
  curr ->kernel = ker;
  curr -> m = m;
  curr-> row = i;
  curr-> column = 1;
  pthread_t tid;
  pthread_create(&tid,NULL,matMulFun,curr);
  pthread_join(tid,NULL);
}

return resultG;
}

